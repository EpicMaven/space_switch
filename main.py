#!/usr/bin/env python3

#
# Nova Labs space_switch
# This script handles the hardware space switch and updating the state in the Nova Labs Event Service.  Toggling the
# physical switch updates the Event Service with the update state and changes the physical LEDs.  The LEDs indicate the
# current state.
#
# LED indicator
# ----------------------------
# all grey            - startup
# all green           - OPEN
# all red             - CLOSED
# 2nd half grey       - changing state, updating Event Service
# 2nd half dark green - Event Service updated to open, waiting for pull from Event Service to confirm
# 2nd half dark red   - Event Service updated to closed, waiting for pull from Event Service to confirm
# 2nd half yellow     - error updating or pulling from Event Service
#
# The Event Service is a simple RESTful service for adding and retrieving events.  An event has a type, value, time,
# and UUID.  The UUID is generated by the Event Service.
#
#

import network, requests, json, time, math
from machine import Pin
import neopixel

# WiFi credentials
WIFI_SSID = "Nova Labs"
WIFI_PASSWORD = "robots4u"

# Event Service type - this needs to be unique and not change over time
EVENT_TYPE = "novalabs_space"

# log file to this script
LOG_FILE = 'space_switch.log'

EVENT_SERVICE_BASE_URL = "http://localhost:8080"
#EVENT_SERVICE_BASE_URL = "http://event.nova-labs.org"
EVENT_SERVICE_ADD_URL = EVENT_SERVICE_BASE_URL + "/events"
EVENT_SERVICE_STATUS_URL = EVENT_SERVICE_BASE_URL + "/events/" + EVENT_TYPE + "/latest"

SWITCH_GPIO = 15
PIXEL_GPIO = 4
PIXEL_COUNT = 12

PIXEL_ALL = list(range(PIXEL_COUNT))
PIXEL_HALF = math.floor(PIXEL_COUNT/2)
PIXEL_75_PCT = math.floor(PIXEL_COUNT*.75)
PIXEL_FIRST_HALF = list(range(0, PIXEL_75_PCT))
PIXEL_SECOND_HALF = list(range(PIXEL_75_PCT, PIXEL_COUNT))

RED = (255, 0, 0)
RED_DARK = (100, 0, 0)
GREEN = (0, 255, 0)
GREEN_DARK = (0, 100, 0)
YELLOW = (255, 255, 0)
GREY = (100, 100, 100)
GREY_DARK = (50, 50, 50)
OFF = (0, 0, 0)

STATE_OPEN = "open"
STATE_CLOSED = "closed"
STATE_ERROR = "error"
STATE_NONE = "none"
UNKNOWN_UUID = "00000000-0000-0000-0000-000000000000"

ERROR_EVENT = {"type": EVENT_TYPE, "value": STATE_ERROR, "epochMillis": 0, "uuid": UNKNOWN_UUID}
NONE_EVENT = {"type": EVENT_TYPE, "value": STATE_NONE, "epochMillis": 0, "uuid": UNKNOWN_UUID}

HTTP_OK = 200
HTTP_CREATED = 201
HTTP_NOT_FOUND = 404
HTTP_ERROR = 500

LOG_FORMAT = '%(asctime)s.%(msecs)03d %(levelname)8s --- %(message)s'
logging.basicConfig(filename=LOG_FILE, filemode='a', format=LOG_FORMAT, datefmt='%Y-%m-%d %H:%M:%S', level=logging.INFO)
logger = logging.getLogger("space_switch")


#
# connect to WiFi
#
def novalabs_connect():
    logger.info("WIFI: connecting to wifi...")
    sta_if = network.WLAN(network.STA_IF)
    sta_if.active(True)
    #sta_if.scan()                          # Scan for available access points
    while not sta_if.isconnected():
        sta_if.connect(WIFI_SSID, WIFI_PASSWORD) # Connect to an AP
    logger.info("WIFI: connected to wifi")


#
# shine all pixels this color
#
def shine_all(color):
    logger.info("LED: shining all | color %s" % repr(color))
    for i in PIXEL_ALL:
        np[i] = color
    np.write()


#
# shine second half of the LEDs to this color
#
def shine_second_half(color):
    logger.info("LED: shining second half | color %s" % repr(color))
    for i in PIXEL_SECOND_HALF:
        np[i] = color
    np.write()


#
# shine every other pixel to this color
#
def shine_alternate(color):
    logger.info("LED: shining alternate | color %s" % repr(color))
    for i in range(PIXEL_COUNT)[::2]:
        np[i] = color
    np.write()


# turn all green to indicate Event Service latest event is open
def shine_open():
    shine_all(GREEN)


# turn all red to indicate Event Service latest event is closed
def shine_closed():
    shine_all(RED)


# change LEDs to reflect Event Service updated with new state, waiting to confirm by fetching event from Event Service
def shine_updated_open():
    shine_second_half(GREEN_DARK)


# change LEDs to reflect Event Service updated with new state, waiting to confirm by fetching event from Event Service
def shine_updated_closed():
    shine_second_half(RED_DARK)


# change LEDs to yellow to indicate error
def shine_error():
    shine_second_half(YELLOW)


# change LEDs to indicate pending update to Event Service
def shine_changing_state():
    shine_second_half(GREY)


# turn all grey on boot
def shine_boot():
    shine_all(GREY_DARK)


# turn off all LEDs
def shine_off():
    shine_all(OFF)


# change LEDs to indicate Event Service state updated, waiting on confirmation by pulling event from Event Service
def shine_updated_state(state):
    if state == STATE_OPEN:
        shine_updated_open()
    elif state == STATE_CLOSED:
        shine_updated_closed()
    else:
        shine_error()


# change LEDs to indicate confirmed state from Event Service latest event state
def shine_new_state(state):
    if state == STATE_OPEN:
        shine_open()
    elif state == STATE_CLOSED:
        shine_closed()
    else:
        shine_error()


#
# returns now UTC as epoch milliseconds
#
def epoch_time():
    millis_float = math.floor(time.time() * 1000)
    return long(millis_float)


#
# returns the current event (state)
#
def get_latest_event():
    try:
        response = requests.get(EVENT_SERVICE_STATUS_URL)
        code = response.status_code
    except:
        code = HTTP_ERROR

    event = 0
    if code == HTTP_OK:
        # good response
        event = response.json()
    elif code == HTTP_NOT_FOUND:
        # event type doesn't exist, so return a none event
        event = NONE_EVENT
    else:
        # error getting current state
        event = ERROR_EVENT
    return event


#
# update the state
#
# 1) turn second half LEDs to indicate state is changing
# 2) send new event to Event Service
# 3) turn second half LEDs to indicate success or failure of updating event
#    success - second half is dark color of new state
#    failure - second half color is yellow
# 4) pull latest event from Event Service (to confirm change)
# 5) turn LEDs to latest state from Event Service, or error lights if can't fetch latest event
#
def update_state(state):
    # indicate changing state
    shine_changing_state()

    # create new state to update the Event Service
    event = {"type": EVENT_TYPE, "value": state, "epochMillis": epoch_time()}
    code = 0
    retries = 3
    # send update to Event Service, re-try up to 3 times
    while code != HTTP_CREATED and retries > 0:
        logger.info("UPDATE: sending update to Event Service | event %s" % json.dumps(event))
        try:
            response = requests.post(EVENT_SERVICE_ADD_URL, json=event)
            code = response.status_code
        except:
            code = HTTP_ERROR
        logger.info("UPDATE: Response to update | code %d" % code)
        retries = retries - 1
        time.sleep(1)

    if code == HTTP_CREATED:
        logger.info("UPDATE: event added to Event Service | event %s" % json.dumps(event))
        # change LEDs to indicate Event Service updated
        shine_updated_state(state)
    else:
        logger.warning("UPDATE: failed adding event to Event Service | code %d | event %s" % (code, json.dumps(event)))
        # change LEDs to indicate error
        shine_error()
        # sleep for 2 second to indicate the error
        time.sleep(2)

    # get latest event state from Event Service - normally should be the just updated event (unless update failed)
    event = get_latest_event()
    # change LEDs to reflect current state (from Event Service)
    shine_new_state(event["value"])


#
# update the new state to open
#
def update_open():
    logger.info("STATE: updating new state | state " + STATE_OPEN)
    update_state(STATE_OPEN)


#
# update the new state to closed
#
def update_closed():
    logger.info("STATE: updating new state | state " + STATE_CLOSED)
    update_state(STATE_CLOSED)


#
# handle switch change
#
def handle_switch_change(switch_state):
    novalabs_connect()
    logger.info("SWITCH: handling switch state change | state %d" % switch_state)
    if switch_state == 0:
        update_closed()
    elif switch_state == 1:
        update_open()
    else:
        logger.info("SWITCH: unknown switch state | state %d" % switch_state)


# ----------------------------------------------------------------------------
# start up
# ----------------------------------------------------------------------------
logger.info("STARTUP: starting")

# setup NeoPixel
np = neopixel.NeoPixel(Pin(PIXEL_GPIO), PIXEL_COUNT)
logger.info("STARTUP: %d neopixels on GPIO %d" % (PIXEL_COUNT, PIXEL_GPIO))

# setup switch
switch = Pin(SWITCH_GPIO, Pin.IN, pull=Pin.PULL_UP)
#switch.irq(trigger=Pin.IRQ_RISING|Pin.IRQ_FALLING, handler=notify_switch_changed)
logger.info("STARTUP: switch on GPIO %d" % (SWITCH_GPIO))

# start with all LEDs dark grey
shine_boot()

# get current switch value, update state with Event Service
old_switch_state = switch.value()
handle_switch_change(old_switch_state)

logger.info("STARTUP: initial value %d" % old_switch_state)
while True:
    current_switch_state = switch.value()
    if old_switch_state == current_switch_state:
        time.sleep_ms(100)
        continue
    old_switch_state = current_switch_state
    logger.info("SWITCH: new value %d" % old_switch_state)
    handle_switch_change(old_switch_state)
